/*
Department of Computer Science
CPCS 324: Algorithms and Data Structures (II) 
Spring 2023 Group Project â€“ Part I
Implement KruskalAlgorithm and Prim Algorithm, and using them to compute the minmum sppaning tree problem

---------------------------------------
Name           | ID         | Section
---------------------------------------
Nuha Makki     | 2024579    | B8	   
Rawan Algamdi  | 2005446    | B8		   
Rawan Aljedani | 1906454    | B0B	
Joud Alahmadi  | 2006214    | B0B		   
---------------------------------------

project link on GitHub:
https://github.com/NuhaMakki/CPCS324_Project.git


*/


package GraphFramework;

import java.util.ArrayList;

// MHPrimAlg: is a subclass of MSTAlgorithm
public class MHPrimAlg extends MSTAlgorithm {
        
    // ---------------------------------------------
    //            variables declaration 
    // ---------------------------------------------
    int totalWeight = 0;
    double StartTime;
    double FinishTime;         
    Graph graph;
    MinHeap minheap;
    ArrayList<Vertex> visitedVertices = new ArrayList<Vertex>();  //represents the list of visited Vertices

    
    
    // ---------------------------------------------
    //               constructor
    // ---------------------------------------------
    
    public MHPrimAlg(Graph graph) {
        this.graph = graph;
        this.minheap= new MinHeap(graph.getEdgeNo());     
    }
    

    // ---------------------------------------------
    //                   functions 
    // ---------------------------------------------   
    
    public void prim(){     
        
        //Start time
        StartTime = System.currentTimeMillis();
        
        //insert initial vertex in the visited Vertices List
        visitVertex(graph.getVertices().get(0));
        
        //insert djacency Verteces to the initial vertex in the min heap
        insertadjacencyVertex(graph.getVertices().get(0));

        Edge minEdge;

        while (!minheap.isEmpty() && MSTResultList.size() < graph.getVeticesNo()-1) {   
            
            // min edge is the root of min heap
            minEdge = minheap.extractMin();

            // CHECK if Source is visited && Target is not visited
            if (minEdge.getSource().isVisited && !minEdge.getTarget().isVisited){
                visitVertex(minEdge.getTarget()); // insert vertex in the visited Vertices List
                insertadjacencyVertex (minEdge.getTarget());  //insert djacency Verteces in the min heap
                MSTResultList.add(minEdge); // insert the edge in the result list
            }             
            else if (!graph.isDigraph && minEdge.getTarget().isVisited && !minEdge.getSource().isVisited){
                visitVertex(minEdge.getSource()); // insert vertex in the visited Vertices List
                insertadjacencyVertex (minEdge.getSource()); //insert djacency Verteces in the min heap
                MSTResultList.add(minEdge); // insert the edge in the result list
            }

        }
        
        //Finish time of the algorithm
        FinishTime = System.currentTimeMillis();
        
        //compute totalWeight Weight
        for (int i = 0; i < MSTResultList.size(); i++) {
            totalWeight += MSTResultList.get(i).weight;
        }
                 
 
    }   


    //this method inserts vertex in the visited Vertices List
    public void visitVertex(Vertex v){
        v.setIsVisited(true);
        visitedVertices.add(v);
    }// End of visitVertex method
    // ---------------------------------------------
    
    //this method inserts djacency Verteces in the min heap
    public void insertadjacencyVertex(Vertex v){
        LLnode hptr = v.getAdjList().getHead();
        while (hptr!=null) {
            minheap.insert(hptr.getAdjacencyVertex());
            hptr=hptr.getNext();
        }
    }// End of insertadjacencyVertex method
    // ---------------------------------------------    

    
    public void displayTimeWeight(){ 
        System.out.printf("      %-6sms.   |  %-15s\n", (FinishTime - StartTime) , totalWeight);
    }// End of displayTimeWeight method
    // ---------------------------------------------
    
    
    @Override
    public void displayResultingMST(){     
        System.out.println("The phone network (minimum spanning tree) generated by min-heap based Prim algorithm is as follows:");
        
        for (int i = 0; i < MSTResultList.size(); i++) {
            System.out.print("\t");
            MSTResultList.get(i).getSource().displayInfo() ;            
            System.out.print(" -    ");
            MSTResultList.get(i).getTarget().displayInfo() ;            
            System.out.print(" :    ");
            MSTResultList.get(i).displayInfo() ;            
            System.out.println("");
        }
        
        System.out.println("\nThe cost of designed phone network: " + totalWeight +"\nThe running time: " + (FinishTime - StartTime) +"\n\n");
    }// End of displayResultingMST method
    // ---------------------------------------------    


}// End of MHPrimAlg class

//----------------------------------------------------------------------------------------------------------


class MinHeap {
   
    // ---------------------------------------------
    //            variables declaration 
    // ---------------------------------------------

    int capacity;
    int Size; //The current size
    Edge [] heapEdges;

    
    // ---------------------------------------------
    //               constructor
    // ---------------------------------------------
    public MinHeap(int capacity) {
        this.capacity = capacity;
        heapEdges = new Edge[capacity + 1];
        Size = 0;
    }
    
    // ---------------------------------------------
    //                   functions 
    // ---------------------------------------------   
    
    // this methos inserts edge in heap
    public void insert(Edge edge) {
        int idx = Size;
        heapEdges[idx] = edge;
        bubbleUp(idx);
        Size++;
    }// End of insert method
    // ---------------------------------------------
    

    // this method locate the inserted edge in the proparate indix
    public void bubbleUp(int Position) {
        int parentIdx = (Position -1) / 2;
        int currentIdx = Position;
        while (currentIdx > 0  && heapEdges[parentIdx].getWeight() > heapEdges[currentIdx].getWeight()) {
            
            swap(currentIdx, parentIdx);
            currentIdx = parentIdx;
            parentIdx = (parentIdx-1) / 2;
        }
    }// End of displayTimeWeight method
    // ---------------------------------------------

    // this method return minEdge (root)
    public Edge extractMin() {
        Edge min = heapEdges[0];
        Edge lastNode = heapEdges[Size-1];
        heapEdges[0] = lastNode;
        heapEdges[Size-1] = null;
        Size--;
        sinkDown(0);
        return min;
    }// End of extractMin method
    // ---------------------------------------------

    
    // this method sort the heap after deletion
    public void sinkDown(int T) {
        int theSmallest = T;
        int leftChild = (2 * T) + 1;
        int rightChild = (2 * T) + 2;
        
        if (leftChild < heapSize() && 
                heapEdges[theSmallest].getWeight() > heapEdges[leftChild].getWeight()) {
            theSmallest = leftChild;
        }
        if (rightChild < heapSize() && 
                heapEdges[theSmallest].getWeight() > heapEdges[rightChild].getWeight()) {
            theSmallest = rightChild;
        }
        if (theSmallest != T) {
            swap(T, theSmallest);
            sinkDown(theSmallest);
        }
    }// End of sinkDown method
    // ---------------------------------------------

    //To Check if heap is empty
    public boolean isEmpty() {
        return Size == 0;
    }// End of isEmpty method
    // ---------------------------------------------

    
    //To get the min Heap Size
    public int heapSize() {
        return Size;
    }// End of heapSize method
    // ---------------------------------------------

    
    // swap method to used in bubbleUp & sinkDown
    public void swap(int x, int y) {
        Edge temp = heapEdges[x];
        heapEdges[x] = heapEdges[y];
        heapEdges[y] = temp;
    }// End of displayTimeWeight method
    // ---------------------------------------------

    
}