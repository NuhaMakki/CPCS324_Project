/*
Department of Computer Science
CPCS 324: Algorithms and Data Structures (II) 
Spring 2023 Group Project â€“ Part I
Implement KruskalAlgorithm and Prim Algorithm, and using them to compute the minmum sppaning tree problem

---------------------------------------
Name           | ID         | Section
---------------------------------------
Nuha Makki     | 2024579    | B8	   
Rawan Algamdi  | 2005446    | B8		   
Rawan Aljedani | 1906454    | B0B	
Joud Alahmadi  | 2006214    | B0B		   
---------------------------------------

project link on GitHub:
https://github.com/NuhaMakki/CPCS324_Project.git


*/


package GraphFramework;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;


//KruskalAlg: is a subclass of MSTAlgorithm
public class KruskalAlg extends MSTAlgorithm {

        
    
    // ---------------------------------------------
    //            variables declaration 
    // ---------------------------------------------
    int totalWeight=0;
    double StartTime;
    double FinishTime;
    Graph graph;
    ArrayList<Edge> allEdges = new ArrayList<Edge>();  //represents the list of Edges of a graph

    
    // ---------------------------------------------
    //               constructor
    // ---------------------------------------------
    public KruskalAlg(Graph graph) {
        this.graph = graph;
    }
  
    
    // ---------------------------------------------
    //                   functions 
    // ---------------------------------------------   
    
    public void kruskal() {
        
        //Start time
        StartTime = System.currentTimeMillis();
        
        // make set & add all graph edges in one ArrayList
        makeSet();
        
        //sort the ArrayList based on weights
        Collections.sort(allEdges, Comparator.comparingInt(o -> o.getWeight()) );
        
        
        while (MSTResultList.size() < graph.veticesNo -1 && !allEdges.isEmpty()) {
            
            // traverse all eges one by one
            Edge edge = allEdges.remove(0);
            
            //check if adding this edge creates a cycle            
            Vertex x_set = find(edge.getSource()  );
            Vertex y_set = find(edge.getTarget() );

            if (x_set == y_set) {
                //Ignore, will create cycle
            }
            
            else {
                //Add it to our final result
                MSTResultList.add(edge);
                
                //  x_set union y_set
                union( x_set, y_set);
            }
        }

        //Finish time of the algorithm
        FinishTime = System.currentTimeMillis();
        
        //compute totalWeight Weight
        for (int i = 0; i < MSTResultList.size(); i++) {
            totalWeight += MSTResultList.get(i).getWeight();
        }
    
    }// End of kruskal method
    // --------------------------------------------- 
 
    
    
    // Chain of parent pointers from x upwards until an element is reached whose parent is itself
    public Vertex find(Vertex vertex) {
        if (vertex.getParent() != vertex) {
            return find(vertex.getParent());
        };
        return vertex; // return the searched vertex
        
    }// End of find method
    // ---------------------------------------------
    

    
    public void union(Vertex x, Vertex y) {
        //Make x as parent of y
        x.setParent(y);
        
    }// End of union method
    // ---------------------------------------------


    public void makeSet(){     
        LLnode hptr;
        for (int i = 0; i < graph.getVeticesNo(); i++) {
            
            // make set (each node is parent for it self)
            graph.getVertices().get(i).setParent(graph.getVertices().get(i));
            
            // add all graph edges in one ArrayList
            hptr=graph.getVertices().get(i).getAdjList().getHead();
            while (hptr!=null) {
                allEdges.add(hptr.getAdjacencyVertex());
                hptr=hptr.getNext();
            }   
        }
    }// End of makeSet method
    // ---------------------------------------------  
    
    public void displayTimeWeight(){ 
        System.out.printf("%-7s|%-7s|   %-6sms.   |  %-15s|",
                graph.getVeticesNo(), graph.getEdgeNo(),  (FinishTime - StartTime) , totalWeight);
    }
    

    @Override
    public void displayResultingMST(){     
        System.out.println("The phone network (minimum spanning tree) generated by Kruskal algorithm is as follows:");
        
        for (int i = 0; i < MSTResultList.size(); i++) {
            System.out.print("\t");
            MSTResultList.get(i).getSource().displayInfo() ;            
            System.out.print(" -    ");
            MSTResultList.get(i).getTarget().displayInfo() ;            
            System.out.print(" :    ");
            MSTResultList.get(i).displayInfo() ;            
            System.out.println("");
        }
        
        System.out.println("\nThe cost of designed phone network: " + totalWeight +"\nThe running time: " + (FinishTime - StartTime) + "\n\n");
    }// End of displayResultingMST method
    // ---------------------------------------------

  
}


